<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Ether BoxCars</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>

    <!-- Plugin CSS -->
    <link href="vendor/magnific-popup/magnific-popup.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/creative.css" rel="stylesheet">

  </head>

  <body id="page-top">

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-default fixed-top" id="mainNav">
      <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="#page-top">BoxCars</a>
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#about">About</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#algorithm">Algorithm</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#roll_section">Roll History</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#code">Code</a>
            </li>
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="#contact">Contact</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <header class="masthead text-center text-black d-flex">
      <div class="container my-auto">
        <div class="row">
          <div class="col-lg-3 mx-auto"> 
		      <h4 align='left'>Key Values</h4>
			  <p align='left'>&nbsp;&nbsp;(in Ether)</p>
			  <table>
			  <tr><td>Player:  </td><td>&nbsp;</td><td id="eth"> </td><td>&Xi;</td></tr>
			  <tr><td>House:   </td><td>&nbsp;</td><td id="house"> </td><td>&Xi;</td></tr>
			  <tr><td>Max Bet: </td><td>&nbsp;</td><td id="max"> </td><td>&Xi;</td></tr>
			  <tr><td>Min Bet: </td><td>&nbsp;</td><td id="min"> </td><td>&Xi;</td></tr>
			  <tr><td>Block: </td><td>&nbsp;</td><td id="block"> </td><td></td></tr>
			  </table>
			  <br>
  		  </div>

          <div class="col-lg-6 mx-auto">
			<div>
	            <h1 class="text-uppercase">
	              <strong>BoxCars</strong>
	            </h1>
	            <hr>
	            <p class="text-faded mb-5">A proof-of-concept multi-round Ethereum dice game <br>- can you roll a double-six in nineteen rolls?</p>
				<div id="bet_div">
					<p> <input type="text" id="bet" placeholder="0.0 &Xi;"/>
			    	<a class="btn btn-primary btn-xl js-scroll-trigger" href="#" onclick="placeBet()">Place Bet</a></p>
				</div>
				<div id="finalize_div">
					<h2 id="current_roll">Roll:</h2>
					<p> <a class="btn btn-primary btn-xl js-scroll-trigger" href="#" onclick="finalizeBet()">Finalize Bet</a></p>
					<p> (You <i>must</i> press 'Finalize Bet' to collect your winnings if you win - the blockchain can't pay out without your input!)</p>
					
				</div>
				<br>
				<br>
				<p style="font-size: small;text-align: justify;">
				<b>Warning</b> - This is a technology test - do not use this site if it is illegal in your jurisdiction.  As this is test code, it will
				only be online for a short time, and may contain errors.  It is intended as a proof of concept to trial some new ways of running
				multi-player, multi-round games on the blockchain, and to test the security of on-chain pseudo-random number generation.
				So keep your 'bets' small, have fun, and let me know if you find any weird things happening...!</p>	
			</div>
		  </div>
		
		  <div class="col-lg-3 mx-auto text-left"> 

			  <div id="roll_summary">
			  	<h4 id="history">72 Recent Rolls:</h4>			  
			  	<p id="rolls" class="dice"></p>
				<p><a href="#roll_section">more...</a></p>
			  </div>
		  </div>
		
        </div>
      </div>
    </header>

    <section class="bg-primary" id="about">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 mx-auto text-left">
			<h2 class="section-heading text-black">A multi-player, multi-round Ethereum game</h2>
            <hr class="dark my-4">
            <p class="text-faded mb-4">This is a test website, to try out some ideas to be used for a more complex roleplaying game. The idea is to simulate round-by-round game play on the blockchain, while keeping gas costs low.</p>
			<p class="text-faded mb-4">In the game, the user place their bet, and then over the next 19 blocks the game 'rolls' two dice using the blockhash for randomness - this is free and doesn't require paying any gas.  If the player 'wins', they then cliam their winning (this costs gas).  Because the blockhash is used, the bet must be claimed within 256 blocks of the start - about an hour.</p>
			<p class="text-faded mb-4">This gives us the security of the blockchain, and the excitement of a multi-round game, without paying gas every round.  It also avoids killing the chain with huge numbers of transactions!</p>
			<h3 class="section-heading text-black">Warning!</h3>
			<p class="text-faded mb-4">This is <b>NOT</b> intended to be a serious gambling game!  This is a proof of concept to test a multi-player, multi-turn on-chain game.  Keep your bets small, and do not play at all if it is illegal in your jurisdiction.  The game is 'rigged' so that the betting limit gets smaller and smaller as the house runs out of money; so while the house will never go entirely broke, it may be that the cost of gas will exceed the value of your bet.</p>
            <a class="btn btn-light btn-xl js-scroll-trigger" href="#page-top">Get Started!</a>
          </div>


        </div>
      </div>
    </section>
	
    <section class="bg-dark text-black" id="algorithm">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto">
			<h2 class="section-heading text-white text-center">What's the Algo?</h2>
            <hr class="light my-4">
            <p class="text-white">BoxCars is a testbed for inexpensive multi-player, multi-round games.  It does this
            using on chain randomness (the player is betting on future blockhashes), and 'personalises' the game by 
            combining the blockhash with the player address. (This also smooths out the house's losses; otherwise all 
            players would win or lose together).</p>
            <p class="text-white">The core algorithm is in the 'getDiceRoll()' method which takes a particular block :</p>
            <hr class="light my-4">
<pre class='code'>
  function getDiceRoll(uint blockNumber, address player) public view returns (uint8 roll) {
      if (blockNumber + 255 > block.number && blockNumber <= block.number) {
          bytes32 result = keccak256(abi.encodePacked(player, blockhash(blockNumber)));
          return uint8(1+(uint256(result)%36));  
      }
      return 0;  // not valid to ask for rolls more than 255 blocks old...
  }
</pre> 
               <hr class="light my-4">
            <p class="text-white">Since this is a 'view' method, it doesn't require any gas to run.  The web front end
			shows the player each 'roll' as it happens, and the only time the player has to pay gas is after they win,
			when they 'claim' their winnings.  (Or when they place a new bet, in which case they also pay to clean up
			any old ones.)</p>
			
			<p><b>Security</b> Something else that I want to test is security.  There is a lot of concern about using 
			the blockhash for 'randomness'.  In this game though, players are betting on future blockhashes - in theory, 
			it seems a bad miner would need to mine an average of 36 blocks, and discard 35, in order to win.  This would 
			seem to be too expensive to be worth doing (?).</p>

            <a class="btn btn-light btn-xl js-scroll-trigger" href="#page-top">Get Started!</a>
          </div>
        </div>
      </div>
    </section>		

    <section class="bg-primary" id="roll_section">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 mx-auto text-center">
			<h2 class="section-heading text-black">Roll History</h2>
            <hr class="light my-4">
            <p class="text-faded mb-4 text-left">This is a list of the 144 (e.g. 36 x 4) most recent rolls (assuming you're running metamask or similar).  Note that sometimes the block chain takes a while to reach consensus, which means that the last few blocks should be treated as 'tentative'.  Financial hubs tend to wait for 12 blocks to be processed before declaring a transaction 'final', although for most practical purposes 6 transactions should be enough.</p>
			<p id="roll_history" class="dice"></p> 
          </div>
        </div>
      </div>
    </section>	

    <section id="code">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 mx-auto text-left">
            <h2 class="section-heading">Contract Source Code</h2>
            <hr class="my-4">
<!-- thanks to https://www.freeformatter.com/ -->
            <pre class="code">
pragma solidity ^0.4.21;

/// @title A 19 round pre-commitment block hash based dice game
/**
  an experimental contract to run a simple pre-commitment dice game, where players bet at even odds
  whether they can roll a 'double six' in 19 'rolls'.  Each roll is a personalised random roll 
  based on the block hash and the player address.  Players bet using 'placeBet' and must collect
  their winnings within 255 blocks (approximately one hour) using 'resolveBet'.
*/

contract BoxCars {

  address public owner;					// the contract owner

  struct bet {							// a simple indexed data structure to track player bets
    uint start_block;					// - the block number when the bet starts
    uint bet_amount;					// - the amount bet
    uint player_index;					// - the index of the bet owner in the player array
  }

  mapping(address =&gt; bet) bets;         // map of current bets, indexed by player
  address[] players;                    // array of current players

  uint public houseBankroll = 0;        // how much free wei the house has to bet (e.g. account value - double the value of outstanding bets)

  event LogBetMade(address accountAddress, uint amount, uint blockNumber);
  event LogBetWon(address accountAddress, uint amount, uint blockNumber);
  event LogBetLost(address accountAddress, uint amount, uint blockNumber);
  event LogTopUp(address accountAddress, uint amount);
  event LogFallback(address accountAddress, uint amount);
  event LogPayment(address accountAddress, uint amount);
  event LogMessage(string msg);
  event LogMessage(string msg, uint value);
  event LogMessage(string msg, address player, uint value);
  
  modifier onlyOwner() {
    require (msg.sender == owner);
    _;
  }

  /**
   * Called by a player to place a bet. A player may only have one bet active at a time. 
   * The method checks and resolves any existing bet first, and fails if a bet is already  
   * in progress, or if the value is outside maximum and minimum limits.
   */

  function placeBet() public payable {
	emit LogMessage(&quot;place bet&quot;, msg.value);
    resolveBet();							  // pays out or clears any existing bet if it is finished
	emit LogMessage(&quot;cleaned up old bets&quot;);
	
    require (bets[msg.sender].bet_amount==0); // a player can only have one bet at a time, so quits if a bet is still running
    require (msg.value &lt; getMaximumBet());	  // bet is too big
    require (msg.value &gt; getMinimumBet() );   // bet is too small 
	require (players.length &lt; 10); 			  // cap number of players to a max of 10
	 	
    addBet(msg.sender, msg.value);			  // set up the bet with a start block number and a bet amount 
  }

  /**
   * see if a particular player has an active
   */

  function playerHasBet(address player) public view returns (bool active) {
     return (bets[player].bet_amount!=0);
  }

  /**
   * Set a limit to the maximum bet, to avoid house being wiped out all at once.
   * note - there's a risk that multiple players bet the max simultaneously, in which case only the first will succeed)
   */

  function getMaximumBet() public view returns (uint max) {
     max = houseBankroll/8;
  }

  /**
   * Sets a lower limit to bets, so that the contract doesn't get DOS-ed.  
   * (Is this even necessary, given gas costs?)
   */

  function getMinimumBet() public view returns (uint min) {
     min = houseBankroll/128;
  }

  /**
   *  Called by 'placeBet()', this adds the bet to the list of current bets, 
   *  creates the bet data structure and sequestors part of the house bankroll
   *  to cover the bet.
   */

  function addBet(address player, uint amount) private {
    require(amount &lt; houseBankroll);  				

    bets[player].start_block = block.number + 1;  // the bet starts on the next block...
    bets[player].bet_amount = amount;
    bets[player].player_index = players.length;
    players.push(player);
    houseBankroll = houseBankroll - amount;

    emit LogBetMade(player, amount, block.number);
  }

  /**
   *  Called by a player to resolve any existing bets.  If they have won, pays out bet to player, 
   *  if they have lost, cleans up old bet and house takes bet.  If bet not won, but 
   *  still in play, does nothing. 
   */

  function resolveBet() public {
    cleanupOldBets();                                          	// remove *all* bets more than 256 blocks old (including any from calling player)

	if (bets[msg.sender].bet_amount &gt; 0) {                     	// check the calling player's bets
      if (isWinningBet()) {                            			// if it's a winner...  
 
		emit LogMessage(&quot;player won!&quot;, msg.sender, bets[msg.sender].start_block);   
				  
        uint amount = bets[msg.sender].bet_amount;  	       	// ...get the amount won		   
        removeBet(bets[msg.sender].player_index);		       	// ...delete bet 		
        msg.sender.transfer(2*amount);					       	// ...payout twice bet amount to winner
      } 
      else if (block.number &gt; bets[msg.sender].start_block + 19) { // bet hasn't won, so...
            houseTakesBet(bets[msg.sender].player_index);	   	  // ...if the bet has run its course, delete losing bet 		
      }
    }
  }

  /**
   * return bet funds to the houseBankroll
   */
 
  function houseTakesBet(uint index) private {
	address player = players[index];
    uint bet_amount = bets[player].bet_amount;              
    bets[player].bet_amount = 0;
    houseBankroll += (2*bet_amount);						// house recovers bet *and* the bankroll put aside								

	emit LogMessage(&quot;player lost!&quot;, player, bets[player].start_block);   		  
    
    removeBet(index);										// remove the bet from the list of bets
  }

  /*
   * Housekeeping to manage players dynamic array and bets mapping
   * This deletes a player from the mapping and array, and shrinks the array.
   */

  function removeBet(uint indexToDelete) private {
    address player = players[indexToDelete];				// player to remove
    delete bets[player];									// remove player bet

    if (indexToDelete+1 &lt; players.length) {
      address listHeadAddress = players[players.length-1];	// get player at head of array
      players[indexToDelete] = listHeadAddress;				// copy over the top of the removed player...
      bets[listHeadAddress].player_index = indexToDelete;	// ... and update bet pointer to player array 	
    }
 
    players.length--;										// deletes the head of the array
  }

  function cleanupOldBets() public {  
    if (players.length&gt;0) {   
	  for (uint index=players.length; index&gt;0; index--) {				// WARNING - The players array is mutable, so iterate from top to bottom
	  if (bets[getPlayer(index-1)].start_block + 255 &lt; block.number)     // cleanup any expired bets
	    houseTakesBet(index-1);									        // WARNING - this alters player array	
	  }
	}
  }

  /**
   *  Convenience function that displays dice rolls for the message sender.
   *  WARNING: Can't get this to work when called from metamask - something to do with returning an array?  
   *           - works fine in test suite.
   */
  function displayDiceRoll(uint blockNumber) public view returns (uint8[2]) {   
     uint8 roll = getDiceRoll(blockNumber, msg.sender);
     return translateDiceRoll(roll);
  }  

  /**
  * takes a number between 1 and 36 inclusive and turns it into two dice rolls; each 1-6 inclusive.
  */
  function translateDiceRoll(uint8 roll) public pure returns (uint8[2]) {
     require(roll&lt;=36);
 
     if (roll == 0) { 							// zero result for expired bet
       return ([0,0]); 
     }   
     uint8 diceA = uint8(1 + ((roll-1)/6));
     uint8 diceB = uint8(1 + ((roll-1)%6));
     return ([diceA, diceB]);
  }

  /**
   *  returns a blockhash based random number between 1 and 36, 
   *  (or 0 if no block hash is available, e.g. due to an expired block).
   */
  function getDiceRoll(uint blockNumber, address player) public view returns (uint8 roll) {
      if (blockNumber + 255 &gt; block.number &amp;&amp; blockNumber &lt;= block.number) {
          bytes32 result = keccak256(abi.encodePacked(player, blockhash(blockNumber)));
          return uint8(1+(uint256(result)%36));  // ignore miniscule modulus bias...
      }
      return 0;  // not valid to ask for rolls more than 255 blocks old...
  }

  /**
   *  Evaluates whether a particular bet is a winner based on evaluating
   *  up to 19 blockhashes after 'start_block'.
   */ 
  function isWinningBet() private returns (bool win) {	
      win = false;
      uint start_block = bets[msg.sender].start_block;

      // check if bet has timed out
      if (block.number &gt; start_block + 255)
      {
          removeBet(bets[msg.sender].player_index);  // can't access blocks more than 255 blocks old
          return false;
      }

      // a bet can be checked before all 19 blocks have passed
      uint endBlock = (block.number &gt; start_block + 19)?start_block+19:block.number;
      for (uint checkBlock = start_block; checkBlock &lt; endBlock; checkBlock++) {
		if (getDiceRoll(checkBlock, msg.sender) == 36)
		  return true;
      }
      return false;
  }

  /*
   * accesses player bet details based on player index in the players array
   */
  function getPlayerBetstart_block(uint playerIndex) private view returns (uint blockNumber)  {
     address playerAddress = players[playerIndex];
     blockNumber = bets[playerAddress].start_block;
  }


  /*
   * accesses player bet details based on player index in the players array
   */
  function getPlayerBetAmount(uint playerIndex) private view returns (uint betAmount) {
     address playerAddress = players[playerIndex];
     betAmount = bets[playerAddress].bet_amount;
  }

  /*
   * accesses player address based on player index in the players array
   */
  function getPlayer(uint playerIndex) private view returns (address player)  {
     player = players[playerIndex];
  }


//  function BoxCars() public {
  constructor() public {
    owner = msg.sender;
  }

 
  // *** administrative and monitoring functions ***

  // explicitly reject fallback payments - included for clarity and to stop accidental bets
  function () public payable {
    revert () ; 
  } 

  /**
   * Allows the owner to withdraw funds that have not been set aside to cover bets
   */

  function withdraw(uint amount) onlyOwner public  {
    require(amount &lt;= houseBankroll);
    houseBankroll -= amount;
    owner.transfer(amount);
  }

  /**
   * Allows owner to add funds to the house bankroll
   */

  function topUp() payable onlyOwner public  {
    houseBankroll += msg.value;
  }

  /**
   *  Allows owner to monitor bankroll
   */

  function getBankroll() onlyOwner public view returns (uint bankroll) {
    bankroll = houseBankroll;
  }

  /**
   *  Allows owner to 'reset' bankroll if it somehow gets out of synch with the account balance
   */

  function reset() onlyOwner public {
	if (players.length==0) houseBankroll = address(this).balance;  // which it should anyway, but this is insurance which resets everything.	
  }


  /**
   *  Allows owner to view list of current players
   */

  function listPlayers() public view onlyOwner returns (address[]) {
      return players;
  }

  /**
   *  Allows the owner to shut down the contract, as long as there are no active bets.
   * (Contract is intended as test only...!)
   */

  function kill() onlyOwner public { 
    if (players.length==0) { selfdestruct(owner); }
  }
}
			</pre>
          </div>
        </div>
      </div>
    </section>
	
    <section class="bg-dark text-black" id="contact">
      <div class="container">

        <div class="row">
          
          <div class="col-lg-4 mr-auto text-center">
            <i class="fa fa-envelope-o fa-3x mb-3 sr-contact"></i>
            <p>This is my first 'real' solidity contract, so really interested in feedback about security, design and coding quality issues
              <a href="mailto:feedback@">feedback@startbootstrap.com</a>
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="vendor/jquery-easing/jquery.easing.min.js"></script>
    <script src="vendor/scrollreveal/scrollreveal.min.js"></script>
    <script src="vendor/magnific-popup/jquery.magnific-popup.min.js"></script>

    <!-- Custom scripts for this template -->
    <script src="js/creative.min.js"></script>

	<!-- Ethereum scripts -->
	<script src="web3.js"></script>
	<!--script src="jquery-3.1.1.slim.min.js"></script-->
	<script src="index.js"></script>

  </body>

</html>
